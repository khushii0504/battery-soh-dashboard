# -*- coding: utf-8 -*-
"""battery_soh.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mhvmgzat2WwxgQSWwTCeajUYU1gq-mw3

**Install Libraries**
"""

!pip install scipy pandas numpy matplotlib seaborn scikit-learn tensorflow

"""# **Import Libraries**"""

import scipy.io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import MinMaxScaler

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

"""# **Upload NASA Dataset**"""

import os

# Unzip the main dataset if not already unzipped
zip_path = '/content/5.+Battery+Data+Set.zip'
extract_path = '/content/5. Battery Data Set'

if not os.path.exists(extract_path):
    !unzip -o '{zip_path}' -d '/content/'

# Now, identify which nested zip file contains B0005.mat and extract it
# Based on common dataset structures, it's often within a similarly named archive.
# We will extract '1. BatteryAgingARC-FY08Q4.zip' as it's a common practice for these datasets.
nested_zip_path = os.path.join(extract_path, '1. BatteryAgingARC-FY08Q4.zip')
nested_extract_path = '/content/' # Extract directly to content for easier access

# Check if the specific .mat file exists after extraction, if not, perform extraction
if not os.path.exists(os.path.join(nested_extract_path, 'B0005.mat')):
    print(f"Extracting nested zip: {nested_zip_path}")
    !unzip -o '{nested_zip_path}' -d '{nested_extract_path}'

# Now, load the B0005.mat file, which should be directly in /content/
mat = scipy.io.loadmat(os.path.join(nested_extract_path, 'B0005.mat'))

"""# **Extract Discharge Capacity Data**"""

battery = mat['B0005'][0][0]

cycles = battery['cycle'][0]

capacity_data = []
cycle_index = []

for i in range(len(cycles)):
    cycle_type = cycles[i]['type'][0]

    if cycle_type == 'discharge':
        data = cycles[i]['data'][0][0]
        capacity = data['Capacity'][0][0]

        capacity_data.append(capacity)
        cycle_index.append(i)

df = pd.DataFrame({
    'Cycle': np.arange(1, len(capacity_data)+1),
    'Capacity': capacity_data
})

df.head()

"""# **Compute SOH**"""

RATED_CAPACITY = 2.0
df['SOH'] = df['Capacity'] / RATED_CAPACITY
df.head()

"""# **Visualize Degradation**"""

plt.figure(figsize=(10,5))
plt.plot(df['Cycle'], df['SOH'])
plt.title("Battery SOH Degradation Curve")
plt.xlabel("Cycle Number")
plt.ylabel("State of Health")
plt.grid()
plt.show()

"""# **Feature Engineering**"""

df['rolling_mean'] = df['Capacity'].rolling(window=5).mean()
df['rolling_std'] = df['Capacity'].rolling(window=5).std()

df = df.dropna()
df.head()

"""Machine Learning Model (Random Forest)
# Train/Test Split (NO SHUFFLE for time series) **bold text**
"""

X = df[['Cycle', 'rolling_mean', 'rolling_std']]
y = df['SOH']

split = int(0.8 * len(df))

X_train = X[:split]
X_test = X[split:]

y_train = y[:split]
y_test = y[split:]

"""Train Model"""

rf_model = RandomForestRegressor(n_estimators=200, random_state=42)
rf_model.fit(X_train, y_train)

rf_pred = rf_model.predict(X_test)

"""Evaluate"""

rf_mae = mean_absolute_error(y_test, rf_pred)
rf_rmse = np.sqrt(mean_squared_error(y_test, rf_pred))
rf_r2 = r2_score(y_test, rf_pred)

print("Random Forest Results")
print("MAE:", rf_mae)
print("RMSE:", rf_rmse)
print("R2:", rf_r2)

"""# **Deep Learning Model (LSTM)**

Scale SOH
"""

scaler = MinMaxScaler()
scaled_soh = scaler.fit_transform(df[['SOH']])

"""Create Sequences"""

def create_sequences(data, window_size=10):
    X, y = [], []
    for i in range(len(data) - window_size):
        X.append(data[i:i+window_size])
        y.append(data[i+window_size])
    return np.array(X), np.array(y)

X_seq, y_seq = create_sequences(scaled_soh, 10)

split = int(0.8 * len(X_seq))

X_train = X_seq[:split]
X_test = X_seq[split:]

y_train = y_seq[:split]
y_test = y_seq[split:]

"""Build LSTM Model"""

lstm_model = Sequential()
lstm_model.add(LSTM(64, input_shape=(X_train.shape[1], 1)))
lstm_model.add(Dense(1))

lstm_model.compile(optimizer='adam', loss='mse')

history = lstm_model.fit(X_train, y_train,
                         epochs=50,
                         batch_size=16,
                         verbose=1)

"""Evaluate LSTM"""

lstm_pred = lstm_model.predict(X_test)

lstm_pred_inv = scaler.inverse_transform(lstm_pred)
y_test_inv = scaler.inverse_transform(y_test)

lstm_mae = mean_absolute_error(y_test_inv, lstm_pred_inv)
lstm_rmse = np.sqrt(mean_squared_error(y_test_inv, lstm_pred_inv))
lstm_r2 = r2_score(y_test_inv, lstm_pred_inv)

print("LSTM Results")
print("MAE:", lstm_mae)
print("RMSE:", lstm_rmse)
print("R2:", lstm_r2)

"""Plot Comparison"""

plt.figure(figsize=(10,5))
plt.plot(y_test_inv, label='Actual SOH')
plt.plot(lstm_pred_inv, label='Predicted SOH')
plt.legend()
plt.title("LSTM SOH Prediction")
plt.show()

"""# **Save Model in Colab**

After training:
"""

import joblib
joblib.dump(rf_model, "rf_model.pkl")

"""For LSTM:"""

lstm_model.save("lstm_model.h5")